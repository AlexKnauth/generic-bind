******** 2013-09-05 ********
- ~for in fast-for branch now as fast (or faster) than racket for
- requires racket/private/for.rkt to provide expand-clause and make-sequence

; times on i7-920, windows 7 64bit, 12gb
; racket cmd line, no xrepl, 1 gc before timing

> (time (let ([n 300]) (for*/fold ([sum1 0][sum2 0][sum3 0]) ([x (in-range n)][y
 (in-range n)][z (in-range n)]) (values (+ x sum1) (+ y sum2) (+ z sum3)))))
cpu time: 5141 real time: 5138 gc time: 156
> (time (let ([n 300]) (~for*/fold ([sum1 0][sum2 0][sum3 0]) ([x (in-range n)][
y (in-range n)][z (in-range n)]) (values (+ x sum1) (+ y sum2) (+ z sum3)))))
cpu time: 5062 real time: 5081 gc time: 140

> (let ([n 150]) (time (for*/lists (l1 l2 l3) ([x (in-range n)] [y (in-range n)]
[z (in-range n)]) (values (list x) (list y) (list z)))) (void))
cpu time: 2047 real time: 2048 gc time: 1844
> (let ([n 150]) (time (~for*/lists (l1 l2 l3) ([x (in-range n)] [y (in-range n)
][z (in-range n)]) (values (list x) (list y) (list z)))) (void))
cpu time: 2031 real time: 2038 gc time: 1845

> (let ([n 200]) (time (~for*/vector ([x (in-range n)] [y (in-range n)] [z (in-r
ange n)]) (list x y z))) (void))
cpu time: 2250 real time: 2247 gc time: 2000
> (let ([n 200]) (time (for*/vector ([x (in-range n)] [y (in-range n)] [z (in-ra
nge n)]) (list x y z))) (void))
cpu time: 2375 real time: 2378 gc time: 2219

> (time (let ([n 200]) (for*/hash ([x (in-range n)][y (in-range n)][z (in-range
n)]) (values x (+ z y))) (void)))
cpu time: 3406 real time: 3408 gc time: 142
> (time (let ([n 200]) (~for*/hash ([x (in-range n)][y (in-range n)][z (in-range
 n)]) (values x (+ z y))) (void)))
cpu time: 3391 real time: 3399 gc time: 187

> (time (let ([n 2000000]) (for/hash ([x (in-range n)][y (in-range n)][z (in-ran
ge n)]) (values x (+ z y))) (void)))
cpu time: 3453 real time: 3455 gc time: 532
> (time (let ([n 2000000]) (~for/hash ([x (in-range n)][y (in-range n)][z (in-ra
nge n)]) (values x (+ z y))) (void)))
cpu time: 3453 real time: 3456 gc time: 547

> (time (let ([n 2000000]) (for/hash ([x (in-range n)][y (in-range n)][z (in-ran
ge n)] #:unless (even? x)) (values x (+ z y))) (void)))
cpu time: 1640 real time: 1648 gc time: 264
> (time (let ([n 2000000]) (~for/hash ([x (in-range n)][y (in-range n)][z (in-ra
nge n)] #:unless (even? x)) (values x (+ z y))) (void)))
cpu time: 1656 real time: 1648 gc time: 233

******** 2013-09-04 ********
- fast-for branch
; i7-2600k, 12gb, racket w no xrepl, after gcing

> (let ([n 200]) (time (~for*/vector ([x (in-range n)] [y (in-range n)] [z (in-range n)]) (list x y z))) (void))
cpu time: 2449 real time: 2454 gc time: 2169
> (let ([n 200]) (time (for*/vector ([x (in-range n)] [y (in-range n)] [z (in-range n)]) (list x y z))) (void))
cpu time: 2896 real time: 2906 gc time: 2676

> (let ([n 200]) (time (~for*/lists (l1 l2 l3) ([x (in-range n)] [y (in-range n)] [z (in-range n)]) (values (list x) (list y) (list z)))) (void))
cpu time: 9324 real time: 9351 gc time: 7596
>  (let ([n 200]) (time (for*/lists (l1 l2 l3) ([x (in-range n)] [y (in-range n)] [z (in-range n)]) (values (list x) (list y) (list z)))) (void))
cpu time: 5852 real time: 5873 gc time: 5236


******** 2013-09-04 ********
- with unsafe ops
; i7-2600k, 12gb, racket w no xrepl, after gcing

> (let ([n 200]) (time (~for*/vector ([x (in-range n)] [y (in-range n)] [z (in-range n)]) (list x y z))) (void))
cpu time: 4912 real time: 4925 gc time: 3532
> (let ([n 200]) (time (for*/vector ([x (in-range n)] [y (in-range n)] [z (in-range n)]) (list x y z))) (void))
cpu time: 2984 real time: 2992 gc time: 2756

> (let ([n 200]) (time (for*/lists (l1 l2 l3) ([x (in-range n)] [y (in-range n)] [z (in-range n)]) (values (list x) (list y) (list z)))) (void))
cpu time: 5900 real time: 5920 gc time: 5304
> (let ([n 200]) (time (~for*/lists (l1 l2 l3) ([x (in-range n)] [y (in-range n)] [z (in-range n)]) (values (list x) (list y) (list z)))) (void))
cpu time: 9752 real time: 9781 gc time: 7516


******** 2013-09-03 ********
- ~for/vector builds list first before copying to vector
- now < 2x slower

; i7-i2600k, 12gb, in racket (no xrepl)
> (let ([n 200]) (time (~for*/vector ([x (in-range n)] [y (in-range n)] [z (in-range n)]) (list x y z))) (void))

cpu time: 5789 real time: 5804 gc time: 4385
> (let ([n 200]) (time (for*/vector ([x (in-range n)] [y (in-range n)] [z (in-range n)]) (list x y z))) (void))
cpu time: 3632 real time: 3645 gc time: 3404

******** 2013-09-02 ********
- added some optimizations in ~for/common seems to speed things up:
  - eliminate checks for #:when #t
  - dont call final unless needed (ie dont just call an id default)
  - dont call break? unless specified (ie no (lambda _ #f) default)
  - remove spurious call-with-values when there is only 1 accum

*** previous timings (in drracket):
- ~for*/lists is ~3x slower than for*/lists
- ~for*/vector is ~3x slower than for*/vector

;> (let ([n 200]) (time (for*/lists (l1 l2 l3) ([x (in-range n)] [y (in-range n)] [z (in-range n)]) (values (list x) (list y) (list z)))) (void))
;cpu time: 5632 real time: 5652 gc time: 4912
;> (let ([n 200]) (time (~for*/lists (l1 l2 l3) ([x (in-range n)] [y (in-range n)] [z (in-range n)]) (values (list x) (list y) (list z)))) (void))
;cpu time: 14237 real time: 14283 gc time: 11061
;> (let ([n 200]) (time (for*/vector ([x (in-range n)] [y (in-range n)] [z (in-range n)]) (list x y z))) (void))
;cpu time: 3100 real time: 3111 gc time: 2852
;> (let ([n 200]) (time (for*/vector ([x (in-range n)] [y (in-range n)] [z (in-range n)]) (list x y z))) (void))
;cpu time: 4901 real time: 4919 gc time: 4636
;> (let ([n 200]) (time (~for*/vector ([x (in-range n)] [y (in-range n)] [z (in-range n)]) (list x y z))) (void))
;cpu time: 17621 real time: 17684 gc time: 14373
;> (let ([n 200]) (time (~for*/vector ([x (in-range n)] [y (in-range n)] [z (in-range n)]) (list x y z))) (void))
;cpu time: 16145 real time: 16306 gc time: 12769

*** new timings (from racket xrepl):
- ~for*/lists went from ~3x slower to ~1.5 slower
- ~for*/vector went from > ~3x slower to < ~3x slower

-> (let ([n 200]) (time (for*/lists (l1 l2 l3) ([x (in-range n)] [y (in-range n)] [z (in-range n)]) (values (list x) (list y) (list z)))) (void))
cpu time: 7541 real time: 7565 gc time: 6949
-> (let ([n 200]) (time (~for*/lists (l1 l2 l3) ([x (in-range n)] [y (in-range n)] [z (in-range n)]) (values (list x) (list y) (list z)))) (void))
cpu time: 10817 real time: 10847 gc time: 8589
-> (let ([n 200]) (time (for*/vector ([x (in-range n)] [y (in-range n)] [z (in-range n)]) (list x y z))) (void))
cpu time: 3216 real time: 3227 gc time: 2988
-> (let ([n 200]) (time (~for*/vector ([x (in-range n)] [y (in-range n)] [z (in-range n)]) (list x y z))) (void))
cpu time: 8840 real time: 8867 gc time: 7428


******** 2013-08-25 ********
common errors and their causes:

** Error: inf loop
** Probable cause:
   stxloop is not properly matching and keeps trying the same part of the list
   This is because #:with is not the same as with-syntax:
   - #:with is part of the match, while with with-syntax, match is already done
   - so if with-syntax fails, it's an error, if #:with fails, it keeps looking
     for a different match

** Error: "expected a generic bind instance in: ( ... )"
** Probable cause: 
 Not properly splicing a syntax-splicing-class pattern variable.

** Error: "no #%app transformer" (or other weird errors)
** Probable cause:
 Bad local-expand and you're not catcing the error properly.
